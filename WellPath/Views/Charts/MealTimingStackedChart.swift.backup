//
//  MealTimingStackedChart.swift
//  WellPath
//
//  Dynamic stacked bar chart for meal-based protein distribution
//  Automatically discovers and renders all meal aggregations
//

import SwiftUI
import Charts

struct MealTimingStackedChart: View {
    let color: Color

    @State private var selectedPeriod: TimePeriod = .week
    @State private var selectedBarDate: Date?
    @State private var selectedMeal: String?  // Which meal segment is selected
    @State private var scrollPosition: Date
    @State private var showPercentage: Bool = false  // Toggle between grams and %
    @StateObject private var viewModel = MealTimingViewModel()

    init(color: Color) {
        self.color = color

        // Initialize scroll position so TODAY is at far right
        // Use VISIBLE WINDOW duration (7 days for week = 7 * 86400 seconds)
        let now = Date()
        let visibleDuration: TimeInterval = 7 * 24 * 3600  // Week view = 7 days
        let scrollStart = Calendar.current.date(
            byAdding: .second,
            value: -Int(visibleDuration),
            to: now
        ) ?? now

        _scrollPosition = State(initialValue: scrollStart)
    }

    var body: some View {
        VStack(spacing: 0) {
            if viewModel.isLoading {
                ProgressView("Loading meal data...")
                    .frame(height: 300)
            } else if viewModel.mealAggregations.isEmpty {
                Text("No meal timing data available")
                    .font(.headline)
                    .foregroundColor(.secondary)
                    .frame(height: 300)
            } else {
                VStack(spacing: 0) {
                    // FIXED: Period picker + chart
                    VStack(spacing: 0) {
                        // Period picker
                        Picker("Period", selection: $selectedPeriod) {
                            ForEach(TimePeriod.allCases, id: \.self) { period in
                                Text(period.rawValue).tag(period)
                            }
                        }
                        .pickerStyle(.segmented)
                        .padding(.horizontal)
                        .padding(.top, 16)
                        .onChange(of: selectedPeriod) { oldValue, newPeriod in
                            selectedBarDate = nil
                            selectedMeal = nil

                            // Set scroll position using VISIBLE WINDOW duration (not numberOfBars!)
                            let now = Date()
                            let visibleDuration = getVisibleDomainTimeInterval()
                            scrollPosition = Calendar.current.date(
                                byAdding: .second,
                                value: -Int(visibleDuration),
                                to: now
                            ) ?? now

                            print("üìä MEAL TIMING: Set scrollPosition=\(scrollPosition) [visible=\(visibleDuration/86400) days, now=\(now)]")

                            // THEN load data async
                            Task {
                                await viewModel.loadData(for: newPeriod)
                                print("üìä MEAL TIMING: Loaded \(viewModel.chartData.count) points")
                            }
                        }

                        // Stacked bar chart
                Chart {
                    ForEach(viewModel.chartData) { dateData in
                        ForEach(dateData.mealValues) { mealValue in
                            // Dim unselected meals when one is selected
                            let opacity: Double = {
                                if selectedMeal == nil {
                                    return 1.0
                                } else if selectedMeal == mealValue.mealName {
                                    return 1.0
                                } else {
                                    return 0.25
                                }
                            }()

                            BarMark(
                                x: .value("Time", dateData.date),
                                y: .value("Grams", getDisplayValue(for: mealValue.value)),
                                width: .fixed(getBarWidth())
                            )
                            .foregroundStyle(mealValue.color.opacity(opacity))
                        }
                    }
                }
                .frame(height: 220)
                .chartScrollableAxes(.horizontal)
                .chartScrollPosition(x: $scrollPosition)
                .chartXVisibleDomain(length: getVisibleDomainTimeInterval())
                .chartGesture { proxy in
                    SpatialTapGesture()
                        .onEnded { value in
                            if let tappedDate: Date = proxy.value(atX: value.location.x) {
                                let closest = viewModel.chartData.min(by: {
                                    abs($0.date.timeIntervalSince(tappedDate)) < abs($1.date.timeIntervalSince(tappedDate))
                                })

                                // Tapping bar selects date (doesn't affect meal selection)
                                if selectedBarDate == closest?.date {
                                    selectedBarDate = nil
                                } else {
                                    selectedBarDate = closest?.date
                                }
                            }
                        }
                }
                .chartXAxis {
                    AxisMarks(values: .stride(by: getAxisStride(), count: getAxisMultiplier())) { value in
                        if value.as(Date.self) != nil {
                            AxisValueLabel(format: getAxisFormat())
                            AxisGridLine()
                        }
                    }
                }
                .chartYAxis {
                    AxisMarks { value in
                        AxisValueLabel()
                        AxisGridLine(stroke: StrokeStyle(lineWidth: 0.5, dash: [2, 3]))
                            .foregroundStyle(Color.secondary.opacity(0.2))
                    }
                }
                .padding(.horizontal)
                .padding(.top, 8)
                .padding(.bottom, 12)
            }
            .background(Color(uiColor: .systemGroupedBackground))

            // SCROLLABLE: Meal averages list
            ScrollView {
                // Grams/% toggle
                HStack {
                    Spacer()
                    Picker("Unit", selection: $showPercentage) {
                        Text("Grams").tag(false)
                        Text("%").tag(true)
                    }
                    .pickerStyle(.segmented)
                    .frame(width: 150)
                }
                .padding(.horizontal)
                .padding(.top, 8)
                .padding(.bottom, 12)

                VStack(spacing: 8) {
                    ForEach(viewModel.mealAggregations) { meal in
                        Button {
                            withAnimation(.easeInOut(duration: 0.2)) {
                                if selectedMeal == meal.displayName {
                                    selectedMeal = nil
                                } else {
                                    selectedMeal = meal.displayName
                                }
                            }
                        } label: {
                            HStack(spacing: 12) {
                                // Colored circle
                                Circle()
                                    .fill(meal.color)
                                    .frame(width: 12, height: 12)

                                Text(meal.displayName)
                                    .font(.subheadline)
                                    .foregroundColor(.primary)
                                    .frame(maxWidth: .infinity, alignment: .leading)

                                // Average value (grams or %)
                                if showPercentage {
                                    let percentage = viewModel.getPercentageFor(meal.aggId, period: selectedPeriod, scrollPosition: scrollPosition)
                                    Text(String(format: "%.0f%%", percentage))
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.primary)
                                } else {
                                    Text(formatValue(viewModel.getAverageFor(meal.aggId, period: selectedPeriod, scrollPosition: scrollPosition)))
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.primary)

                                    Text("g")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                            }
                            .padding()
                            .background(
                                RoundedRectangle(cornerRadius: 12)
                                    .fill(selectedMeal == meal.displayName ? meal.color.opacity(0.15) : Color(uiColor: .secondarySystemGroupedBackground))
                            )
                        }
                    }
                }
                .padding(.horizontal)
                .padding(.vertical, 8)
            }
            .background(Color(uiColor: .systemGroupedBackground))
            }  // closes inner VStack (else block content)
        }  // closes else block
        }  // closes main VStack (line 39)
        .task {
            await viewModel.discoverMealAggregations(baseColor: color)
            await viewModel.loadData(for: selectedPeriod)

            // Set scroll position using VISIBLE WINDOW duration
            let now = Date()
            let visibleDuration: TimeInterval = 7 * 24 * 3600  // Week view
            scrollPosition = Calendar.current.date(
                byAdding: .second,
                value: -Int(visibleDuration),
                to: now
            ) ?? now
            print("üìä MEAL TIMING: Set scrollPosition to \(scrollPosition) for NOW=\(now) [initial load]")
        }  // closes .task
    }  // closes var body

    // MARK: - Helpers

    private func getDisplayValue(for rawValue: Double) -> Double {
        switch selectedPeriod {
        case .day, .week, .month:
            return rawValue
        case .sixMonth:
            return rawValue / 7.0
        case .year:
            return rawValue / 30.0
        }
    }

    private func getBarWidth() -> CGFloat {
        switch selectedPeriod {
        case .day: return 10
        case .week: return 35
        case .month: return 8
        case .sixMonth: return 10
        case .year: return 22
        }
    }

    private func getVisibleDomainTimeInterval() -> TimeInterval {
        switch selectedPeriod {
        case .day: return TimeInterval(24 * 3600)  // 24 hours
        case .week: return TimeInterval(7 * 24 * 3600)  // 7 days
        case .month: return TimeInterval(33 * 24 * 3600)  // 33 days (matches numberOfBars!)
        case .sixMonth: return TimeInterval(26 * 7 * 24 * 3600)  // 26 weeks
        case .year: return TimeInterval(12 * 30 * 24 * 3600)  // 12 months (~365 days)
        }
    }

    // Stride for axis labels (what to display, not data granularity)
    private func getAxisStride() -> Calendar.Component {
        switch selectedPeriod {
        case .day: return .hour
        case .week: return .day
        case .month: return .weekOfYear  // Weekly labels for month view
        case .sixMonth: return .month  // Monthly labels for 6-month view
        case .year: return .month
        }
    }

    private func getAxisMultiplier() -> Int {
        switch selectedPeriod {
        case .day: return 6  // Every 6 hours
        case .week: return 1  // Every day
        case .month: return 1  // Every week
        case .sixMonth: return 1  // Every month
        case .year: return 1  // Every month
        }
    }

    private func getAxisFormat() -> Date.FormatStyle {
        switch selectedPeriod {
        case .day: return .dateTime.hour(.defaultDigits(amPM: .abbreviated))
        case .week: return .dateTime.weekday(.narrow)
        case .month: return .dateTime.day(.defaultDigits)
        case .sixMonth: return .dateTime.month(.abbreviated)
        case .year: return .dateTime.month(.narrow)
        }
    }

    private func formatValue(_ value: Double) -> String {
        if value == 0 {
            return "0"
        } else if value >= 100 {
            return String(format: "%.0f", value)
        } else if value >= 10 {
            return String(format: "%.1f", value)
        } else {
            return String(format: "%.2f", value)
        }
    }
}

// MARK: - ViewModel

@MainActor
class MealTimingViewModel: ObservableObject {
    @Published var mealAggregations: [MealAggregation] = []
    @Published var chartData: [MealStackedData] = []
    @Published var isLoading = false

    private var mealDataCache: [String: [ChartDataPoint]] = [:]
    private let supabase = SupabaseManager.shared.client

    func discoverMealAggregations(baseColor: Color) async {
        // Query aggregation_metrics for all protein meal aggregations
        do {
            struct AggMetric: Codable {
                let aggId: String
                let metricName: String
                let displayName: String

                enum CodingKeys: String, CodingKey {
                    case aggId = "agg_id"
                    case metricName = "metric_name"
                    case displayName = "display_name"
                }
            }

            let results: [AggMetric] = try await supabase
                .from("aggregation_metrics")
                .select("agg_id, metric_name, display_name")
                .or("metric_name.like.%protein%breakfast%,metric_name.like.%protein%lunch%,metric_name.like.%protein%dinner%,metric_name.like.%protein%snack%")
                .execute()
                .value

            print("üçΩÔ∏è Discovered \(results.count) meal aggregations")
            for result in results {
                print("  - \(result.aggId): \(result.displayName) (\(result.metricName))")
            }

            // Sort meals in chronological order (earliest to latest)
            let mealOrder: [String: Int] = [
                "Breakfast Protein": 1,
                "Morning Snack Protein": 2,
                "Lunch Protein": 3,
                "Afternoon Snack Protein": 4,
                "Dinner Protein": 5,
                "Evening Snack Protein": 6
            ]

            let colorCount = Double(results.count)
            mealAggregations = results.enumerated().sorted(by: {
                let order1 = mealOrder[$0.element.displayName] ?? 99
                let order2 = mealOrder[$1.element.displayName] ?? 99
                return order1 < order2
            }).map { index, agg in
                // Create gradient from light to dark (UI/UX recommendation: 0.55-1.0)
                let progress = colorCount > 1 ? Double(index) / (colorCount - 1) : 0
                let opacity = 0.55 + (progress * 0.45)  // Range 0.55 to 1.0 (better contrast)

                // Clean display name
                let cleanName = agg.displayName.replacingOccurrences(of: " Protein", with: "")

                return MealAggregation(
                    aggId: agg.aggId,
                    displayName: cleanName,
                    color: baseColor.opacity(opacity)
                )
            }

        } catch {
            print("‚ùå Error discovering meal aggregations: \(error)")
        }
    }

    func loadData(for period: TimePeriod) async {
        isLoading = true
        mealDataCache.removeAll()

        do {
            let userId = try await supabase.auth.session.user.id
            let periodType = period.databasePeriodType
            let aggIds = mealAggregations.map { $0.aggId }

            // Fetch ALL meal data (no date filters - ParentMetricBarChart pattern)
            let results: [AggregationResult] = try await supabase
                .from("aggregation_results_cache")
                .select()
                .eq("patient_id", value: userId)
                .in("agg_metric_id", values: aggIds)
                .eq("period_type", value: periodType)
                .eq("calculation_type_id", value: "SUM")
                .order("period_start", ascending: true)
                .execute()
                .value

            print("üçΩÔ∏è Fetched \(results.count) meal data points (ALL data, no date filter)")
            print("üçΩÔ∏è Period type: \(periodType), Querying for agg_ids: \(aggIds)")
            if results.count > 0 {
                print("üçΩÔ∏è Sample results:")
                for result in results.prefix(5) {
                    print("  - \(result.aggMetricId): \(result.periodStart) = \(result.value)")
                }
            }

            // Group by agg_metric_id
            for result in results {
                if mealDataCache[result.aggMetricId] == nil {
                    mealDataCache[result.aggMetricId] = []
                }
                mealDataCache[result.aggMetricId]?.append(ChartDataPoint(
                    date: result.periodStart,
                    value: result.value,
                    label: ""
                ))
            }

            // Build stacked chart data with complete timeline
            buildStackedDataWithTimeline(for: period)

        } catch {
            print("‚ùå Error loading meal data: \(error)")
        }

        isLoading = false
    }

    // Infinite scrollable chart (using native Charts scrolling)
            let _ = print("üìä Chart data count: \(scrollManager.chartData.count)")
            Chart(scrollManager.chartData) { dataPoint in
                BarMark(
                    x: .value("Time", dataPoint.date),
                    y: .value("Value", getDisplayValue(for: dataPoint.value)),
                    width: .fixed(getBarWidth())
                )
                .foregroundStyle(selectedBarDate == dataPoint.date ? color.opacity(0.6) : color)
            }
            .frame(height: 280)
            .chartScrollableAxes(.horizontal)
            .chartScrollPosition(x: $scrollPosition)
            .chartXVisibleDomain(length: getVisibleDomainTimeInterval())
            .chartGesture { proxy in
                SpatialTapGesture()
                    .onEnded { value in
                        // Convert tap location to chart data value
                        if let tappedDate: Date = proxy.value(atX: value.location.x) {
                            // Find closest data point
                            let closest = scrollManager.chartData.min(by: {
                                abs($0.date.timeIntervalSince(tappedDate)) < abs($1.date.timeIntervalSince(tappedDate))
                            })

                            if selectedBarDate == closest?.date {
                                // Deselect if tapping same bar
                                selectedBarDate = nil
                            } else {
                                selectedBarDate = closest?.date
                            }
                            print("‚úÖ Tapped bar: \(selectedBarDate?.description ?? "none")")
                        }
                    }
            }
            .onChange(of: scrollPosition) { oldValue, newValue in
                print("üìç Scroll position: \(newValue)")
                // Check if we need to load more data based on scroll position
                handleChartScrolling(position: newValue)
            }
            .chartXAxis {
                AxisMarks(values: .stride(by: getAxisLabelStride(), count: getAxisLabelMultiplier())) { value in
                    if let date = value.as(Date.self) {
                        AxisValueLabel(format: getAxisLabelFormat())
                        AxisGridLine()
                        AxisTick()
                    }
                }
            }
            .chartYAxis {
                AxisMarks { value in
                    AxisValueLabel()
                    AxisGridLine(
                        stroke: StrokeStyle(
                            lineWidth: 0.5,
                            dash: [2, 3]
                        )
                    )
                    .foregroundStyle(Color.secondary.opacity(0.2))
                }
            }
            .chartPlotStyle { plotArea in
                plotArea.frame(height: 280)
            }
            .padding(.horizontal)
            .padding(.top, 16)
            .padding(.bottom, 24)
            
            
            // Loading indicators
            HStack {
                if scrollManager.isLoadingOlder {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Loading older data...")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Spacer()
                if scrollManager.isLoadingNewer {
                    Text("Loading newer data...")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    ProgressView()
                        .scaleEffect(0.8)
                }
            }
            .frame(height: 20)
            .padding(.horizontal)
        }
        .background(Color(uiColor: .systemGroupedBackground))
    

    // MARK: - Infinite Scroll Detection

    private func handleScrolling(offset: CGFloat) {
        let chartWidth = getChartWidth()
        let screenWidth = UIScreen.main.bounds.width
        
        // Load older data when scrolled near beginning
        if offset > -200 && !scrollManager.isLoadingOlder {
            print("√∞≈∏‚Äù‚Äû Near beginning, loading older data...")
            scrollManager.loadOlderData()
        }
        
        // Load newer data when scrolled near end
        let distanceFromEnd = chartWidth + offset - screenWidth
        if distanceFromEnd < 200 && !scrollManager.isLoadingNewer {
            print("√∞≈∏‚Äù‚Äû Near end, loading newer data...")
            scrollManager.loadNewerData()
        }
    }
    
    // MARK: - Chart Scroll Handlers

    private func handleChartScrolling(position: Date) {
        guard !scrollManager.chartData.isEmpty else { return }

        let calendar = Calendar.current
        let component = selectedPeriod.calendarComponent

        // Check if scrolling near oldest data
        if let oldestDate = scrollManager.chartData.last?.date {
            let diff = calendar.dateComponents([component], from: oldestDate, to: position)
            let units = abs(diff.value(for: component) ?? 0)

            // Load older data if within 5 units of oldest
            if units < 5 && !scrollManager.isLoadingOlder {
                print("üìÑ Scrolling near oldest date, loading older data...")
                scrollManager.loadOlderData()
            }
        }

        // Check if scrolling near newest data
        if let newestDate = scrollManager.chartData.first?.date {
            let diff = calendar.dateComponents([component], from: position, to: newestDate)
            let units = abs(diff.value(for: component) ?? 0)

            // Load newer data if within 5 units of newest
            if units < 5 && !scrollManager.isLoadingNewer {
                print("üìÑ Scrolling near newest date, loading newer data...")
                scrollManager.loadNewerData()
            }
        }
    }

    private func handleChartScroll(position: Date?) {
        guard let position = position else { return }

        // Check if we're near the edges and need to load more data
        if let oldestDate = scrollManager.chartData.last?.date {
            let calendar = Calendar.current
            let component = selectedPeriod.calendarComponent
            let diff = calendar.dateComponents([component], from: oldestDate, to: position)
            let units = diff.value(for: component) ?? 0

            // Load older data if scrolling back and within 5 units of oldest data
            if abs(units) < 5 && !scrollManager.isLoadingOlder {
                print("Near oldest data, loading older...")
                scrollManager.loadOlderData()
            }
        }

        if let newestDate = scrollManager.chartData.first?.date {
            let calendar = Calendar.current
            let component = selectedPeriod.calendarComponent
            let diff = calendar.dateComponents([component], from: position, to: newestDate)
            let units = diff.value(for: component) ?? 0

            // Load newer data if scrolling forward and within 5 units of newest data
            if abs(units) < 5 && !scrollManager.isLoadingNewer {
                print("Near newest data, loading newer...")
                scrollManager.loadNewerData()
            }
        }
    }
    
    private func getVisibleDomainLength() -> Int {
        switch selectedPeriod {
        case .day:
            return 24 // 24 hours
        case .week:
            return 7 // 7 days
        case .month:
            return 30 // 30 days
        case .sixMonth:
            return 26 // 26 weeks
        case .year:
            return 12 // 12 months
        }
    }

    private func getDateUnit() -> Calendar.Component {
        switch selectedPeriod {
        case .day: return .hour
        case .week: return .day
        case .month: return .day
        case .sixMonth: return .weekOfYear
        case .year: return .month
        }
    }

    private func getAxisStride() -> Calendar.Component {
        switch selectedPeriod {
        case .day: return .hour
        case .week: return .day
        case .month: return .day
        case .sixMonth: return .weekOfYear
        case .year: return .month
        }
    }

    // Stride for axis labels (can differ from data stride)
    private func getAxisLabelStride() -> Calendar.Component {
        switch selectedPeriod {
        case .day: return .hour
        case .week: return .day
        case .month: return .weekOfYear  // Weekly labels for month view
        case .sixMonth: return .month  // Monthly labels for 6-month view
        case .year: return .month
        }
    }

    private func getAxisLabelMultiplier() -> Int {
        switch selectedPeriod {
        case .day: return 6  // Every 6 hours (12 AM, 6 AM, 12 PM, 6 PM)
        case .week: return 1  // Every day
        case .month: return 1  // Every week
        case .sixMonth: return 1  // Every month
        case .year: return 1  // Every month
        }
    }

    private func getAxisLabelFormat() -> Date.FormatStyle {
        switch selectedPeriod {
        case .day:
            return .dateTime.hour(.defaultDigits(amPM: .abbreviated))
        case .week:
            return .dateTime.weekday(.narrow)
        case .month:
            return .dateTime.day(.defaultDigits)  // Just day number (12, 19, etc.)
        case .sixMonth:
            return .dateTime.month(.abbreviated)
        case .year:
            return .dateTime.month(.narrow)  // Single letter (J, F, M, A, M, J, J, A, S, O, N, D)
        }
    }

    private func getVisibleDomainTimeInterval() -> TimeInterval {
        switch selectedPeriod {
        case .day:
            return 24 * 3600 // 24 hours in seconds
        case .week:
            return 7 * 24 * 3600 // 7 days in seconds
        case .month:
            return 30 * 24 * 3600 // 30 days in seconds
        case .sixMonth:
            return 26 * 7 * 24 * 3600 // 26 weeks in seconds
        case .year:
            return 365 * 24 * 3600 // 1 year in seconds
        }
    }

    private func getBarWidth() -> CGFloat {
        switch selectedPeriod {
        case .day:
            return 10  // Narrow - 24 bars need to fit
        case .week:
            return 35  // 7 bars
        case .month:
            return 8   // Very narrow - 30 bars need to fit
        case .sixMonth:
            return 10  // 26 bars need to fit
        case .year:
            return 22  // 12 bars
        }
    }    

    private func getXAxisMarkValues() -> [Date] {
        switch selectedPeriod {
        case .day:
            // Show 12 AM, 6 AM, 12 PM, 6 PM
            return scrollManager.chartData.compactMap { point in
                let hour = Calendar.current.component(.hour, from: point.date)
                return (hour == 0 || hour == 6 || hour == 12 || hour == 18) ? point.date : nil
            }
            
        case .week:
            // Show every day
            return scrollManager.chartData.map { $0.date }
            
        case .month:
            // Show only Mondays (weekday == 2)
            return scrollManager.chartData.compactMap { point in
                let weekday = Calendar.current.component(.weekday, from: point.date)
                return weekday == 2 ? point.date : nil
            }
            
        case .sixMonth:
            // Show start of each month
            var marks: [Date] = []
            var lastMonth = -1
            for point in scrollManager.chartData {
                let month = Calendar.current.component(.month, from: point.date)
                if month != lastMonth {
                    marks.append(point.date)
                    lastMonth = month
                }
            }
            return marks
            
        case .year:
            // Show each month
            return scrollManager.chartData.map { $0.date }
        }
    }
    
    private func getDateMatchingUnit() -> Calendar.Component {
        switch selectedPeriod {
        case .day:
            return .hour
        case .week, .month:
            return .day
        case .sixMonth:
            return .weekOfYear
        case .year:
            return .month
        }
    }

    private func getDateMatchingComponents() -> DateComponents {
        switch selectedPeriod {
        case .day:
            return DateComponents(hour: 1)
        case .week, .month:
            return DateComponents(day: 1)
        case .sixMonth:
            return DateComponents(weekOfYear: 1)
        case .year:
            return DateComponents(month: 1)
        }
    }
    
    private func getInitialScrollPosition() -> Date {
        // Start at the most recent date (first item since data is reversed)
        return scrollManager.chartData.first?.date ?? Date()
    }



// MARK: - Data Models

struct MealAggregation: Identifiable {
    let id = UUID()
    let aggId: String
    let displayName: String
    let color: Color
}

struct MealStackedData: Identifiable {
    let id = UUID()
    let date: Date
    let mealValues: [MealValue]
}

struct MealValue: Identifiable {
    let id = UUID()
    let mealName: String
    let value: Double
    let color: Color
}

// MARK: - Legend Item

struct LegendItem: View {
    let label: String
    let color: Color

    var body: some View {
        HStack(spacing: 6) {
            RoundedRectangle(cornerRadius: 3)
                .fill(color)
                .frame(width: 16, height: 16)
            Text(label)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

// MARK: - Meal Value Display

struct MealValueDisplay: View {
    let label: String
    let value: Double
    let color: Color

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(label)
                .font(.caption2)
                .foregroundColor(.secondary)
                .textCase(.uppercase)

            HStack(alignment: .firstTextBaseline, spacing: 2) {
                Text(String(format: "%.1f", value))
                    .font(.title3)
                    .fontWeight(.semibold)
                    .foregroundColor(color)
                Text("g")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
    }
}

#Preview {
    MealTimingStackedChart(color: MetricsUIConfig.getPillarColor(for: "Healthful Nutrition"))
}
